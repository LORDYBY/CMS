
==========================================
DIGITAL SIGNAGE CMS â€” FULL ARCHITECTURE DOCUMENTATION
VERSION D â€” README + ASCII DIAGRAMS + DEV ONBOARDING
==========================================

# ğŸ“˜ README.md â€” Architecture Overview

This project follows a Clean Architecture and Domain-Driven Design (DDD) approach to build a scalable, testable, and maintainable digital signage backend.

The architecture separates:

- Domain logic (business rules)
- Application logic (use cases)
- Infrastructure (DB, Filesystem, Redis, WebSockets)
- API layer (REST + WebSocket)

------------------------------------------
TOP-LEVEL STRUCTURE
------------------------------------------

alembic/                  â†’ Database migrations  
app/                      â†’ Main application (code)  
backend/                  â†’ Legacy or static backend (unused)  
digital_signage_backend.egg-info/ â†’ Python package metadata  
docker/                   â†’ Docker, NGINX, deployment config  
media/                    â†’ Media storage (uploads, tenants)  
venv/                     â†’ Python virtual environment  

------------------------------------------
APP STRUCTURE (Clean Architecture)
------------------------------------------

app/
â”œâ”€â”€ api/                  â†’ Presentation layer (REST & WebSocket)
â”œâ”€â”€ common/               â†’ Shared utilities, exceptions, helpers
â”œâ”€â”€ domain/               â†’ Business rules (Entities, Value Objects, Policies)
â”œâ”€â”€ infrastructure/       â†’ Technical details (DB, Redis, FS)
â”œâ”€â”€ use_cases/            â†’ Application logic (actions)
â””â”€â”€ tests/                â†’ Unit & integration tests

------------------------------------------
API LAYER â€” app/api/
------------------------------------------

api/
â”œâ”€â”€ rest/                 â†’ FastAPI routes (HTTP)
â”œâ”€â”€ schemas/              â†’ Pydantic API DTOs
â””â”€â”€ ws/                   â†’ WebSocket endpoints

The API layer:
âœ” Validates input  
âœ” Calls use cases  
âœ” Returns response DTOs  

It does NOT contain business logic.

------------------------------------------
DOMAIN LAYER â€” app/domain/
------------------------------------------

The domain represents PURE BUSINESS LOGIC.

domain/
â”œâ”€â”€ entities/             â†’ Core business entities (Device, Playlist, Mediaâ€¦)
â”œâ”€â”€ enums/                â†’ Enumerations
â”œâ”€â”€ media/                â†’ Media domain rules
â”œâ”€â”€ policies/             â†’ Business invariants
â””â”€â”€ value_objects/        â†’ Immutable objects

Domain has:
âœ” Rules  
âœ” Invariants  
âœ” Pure models  

Domain does NOT:
âœ˜ Talk to DB  
âœ˜ Know HTTP  
âœ˜ Know FastAPI  

------------------------------------------
USE CASE LAYER â€” app/use_cases/
------------------------------------------

Use cases represent APPLICATION LOGIC.

use_cases/
â”œâ”€â”€ audit/
â”œâ”€â”€ auth/
â”œâ”€â”€ content/
â”œâ”€â”€ devices/
â”œâ”€â”€ emergency/
â””â”€â”€ playlist/

Use cases:
âœ” Apply workflow logic  
âœ” Use repositories  
âœ” Apply domain rules  
âœ” Return DTOs  

Use cases DO NOT:
âœ˜ Know HTTP  
âœ˜ Access the DB directly  
âœ˜ Handle JSON  

------------------------------------------
INFRASTRUCTURE LAYER â€” app/infrastructure/
------------------------------------------

Adapters and frameworks:

infrastructure/
â”œâ”€â”€ auth/                 â†’ JWT, password hashing
â”œâ”€â”€ db/
â”‚   â”œâ”€â”€ models/           â†’ SQLAlchemy ORM models
â”‚   â”œâ”€â”€ repositories/     â†’ Repository implementations
â”œâ”€â”€ filesystem/           â†’ Media file handling
â”œâ”€â”€ redis/                â†’ Pub/Sub client
â””â”€â”€ websocket/            â†’ WS connection manager

Infrastructure does:
âœ” Implement interfaces for use cases  
âœ” Handle databases, files, redis  
âœ” Manage tokens  

------------------------------------------
ASCII DIAGRAM â€” CLEAN ARCHITECTURE
------------------------------------------

             +-----------------------+
             |       API Layer       |
             |  REST / WebSockets    |
             +-----------+-----------+
                         |
                         v
               +---------+----------+
               |      Use Cases     |
               +---------+----------+
                         |
                         v
               +---------+----------+
               |     Domain Layer   |
               | Entities / Policies|
               +---------+----------+
                         |
          +--------------+----------------+
          | Infrastructure Layer (DB, FS, |
          | Redis, WebSocket, Auth, etc) |
          +-------------------------------+

------------------------------------------
ASCII DIAGRAM â€” REQUEST FLOW
------------------------------------------

Client
  â†“
API (FastAPI)
  â†“
Use Case
  â†“
Domain (entities + rules)
  â†“
Repository (DB)
  â†“
Infrastructure (FS, Redis, WS)
  â†“
Use Case Output
  â†“
API Response (DTO)
  â†“
Client

------------------------------------------
DEVELOPER ONBOARDING GUIDE
------------------------------------------

Welcome to the Digital Signage CMS backend!

# 1. Requirements
- Python 3.10+
- PostgreSQL
- Redis
- FFmpeg (optional for future transcoding)
- Docker (recommended)

# 2. Setup Environment

Create virtual environment:
python -m venv venv
source venv/bin/activate  (Linux)
venv\Scripts\activate   (Windows)

Install dependencies:
pip install -r requirements.txt

# 3. Initialize Database
Run Alembic migrations:
alembic upgrade head

# 4. Project Run (Dev)
uvicorn app.api.rest.main:app --reload

# 5. Running Tests
pytest -q

# 6. Architecture Principles
- Do NOT put business logic in API
- Do NOT access database in use cases directly
- Domain is PURE and isolated
- Infrastructure is replaceable
- DTOs for ALL input/output
- WebSocket events handled via use cases

# 7. Coding Rules
âœ” Always create a DTO for new API requests  
âœ” Always create a Use Case for new business actions  
âœ” Repositories must NOT contain business rules  
âœ” Domain entities must validate themselves  
âœ” No circular dependencies allowed  

# 8. Adding a New Feature
Example: â€œSuspend a Deviceâ€

Steps:
1. Add a domain rule (policy)
2. Add a use case (SuspendDeviceUseCase)
3. Add repository method â†’ update device status
4. Add API endpoint â†’ call use case
5. Add tests

# 9. Folder Responsibility Summary
api/            â†’ HTTP & WS interface  
use_cases/      â†’ Application logic  
domain/         â†’ Pure business logic  
infrastructure/ â†’ DB, FS, Redis adapters  
common/         â†’ Shared utilities  
tests/          â†’ Test suite  

------------------------------------------
END OF DOCUMENT
------------------------------------------
